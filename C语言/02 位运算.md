[TOC]
#02 位运算
###1 位逻辑运算符
4个位运算符用于整型数据，包含char。将这些运算符称为位运算符的原因是他们对每位进行操作，而不影响左右两侧的位。请不要将这些运算符与常规的逻辑运算符(`&&`、`||`和`!`)混淆，常规的逻辑运算符对整个值进行操作。<br>
####1.1 按位取反:~
一元运算符`~`将每个1变为0，将每个0变为1，如下面的例子所示：<br>

```
~(1001 1010) =
 (0110 0101)
```
####1.2 位与(AND):&
二进制运算符`&`通过对两个操作数逐位进行比较产生一个新值。对于每个位，只有两个操作数的对应位都是1时，结果才为1。因此：<br>

```
(1001 0011) &
(0011 1101) =
(0001 0001)
```
####1.3 位或(OR):|
二进制运算符`|`通过对两个操作数逐位进行比较产生一个新值。对于每一位，如果其中任意操作数中对应位为1，那么结果位就是1。因此：<br>

```
(1001 0011) |
(0011 1101) =
(1011 1111)
```
####1.4 位异或:^
二进制运算符`^`对两个操作数逐位进行比较。对于每一位，如果操作数中的对应位有一个为1（但是不都为1），那么结果为1。因此：<br>

```
(1001 0011) ^
(0011 1101) =
(1010 1110)
```
###2 位运算的用法
####2.1 掩码
位运算符通常跟掩码一起使用。掩码是某些位设为开（1），而某些位设为关（0）的位组合。<br>
例如：定义符号常量`MASK`为2，既二进制`0000 0010`，只有1位是非0，那么：<br>

``` c
flags = flags & MASK;
```
这个语句导致flags的除了位1的所有位都被设为0，原因是它的任何位使用&运算符与0组合都的0。位1讲保持不变（如果该位为1，则`1&1=1`；如果该位为0，则`0&1＝0`）。因为掩码中的0覆盖了`flags`中对应位，所以改过程称为“使用掩码”。<br>
依次类推，您可以讲掩码中的0看成不透明，讲1看成透明。表达式`flags&MASK`就好像使用掩码覆盖`flags`位组合，`flags`中的位只有在`MASK`中的对应位是1时才可见。<br>
一种常用的用法如下面的语句：<br>

``` c
ch &= 0XFF;
```
该操作将留下`ch`的最后8位，将其它位设为0。无论最初的`ch`是8位、16位或者更多，都将最终修整到一个字节中。在这个例子中掩码的宽度为8位。<br>
####2.2 打开位
不影响其它位，同时将特定位打开（将这一位设为1）。您可以使用“或”运算符来实现。<br>
例如，考虑`MASK`，其位1设为1。下面的语句将`flags`中的位1设为1，同时其它位保持不变：<br>

``` c
flags ＝ flags | MASK; // MASK = 0X02
```
这是因为任何位使用`|`运算符与0相组合，结果为该位本身，任何位使用`|`运算符与1组合结果为1。<br>
####2.3 关闭位
不影响其它位，同时将特定位关闭（将这一位设为0）。您可以使用“与”运算符来实现。<br>
例如，关闭变量flags中的位1。MASK仍然是0X02:<br>

``` c
flags ＝ flags & MASK; // MASK ＝ 0X02
```
####2.4 转置位
转置（toggling）一个位表示如果该位打开，则关闭该位；如果该位关闭，则打开该位。您可以使用“异或”运算符来转置一个位。<br>
其思路是：如果b（一个位）为1，则`(b^1)=0`；如果b为0，则`(b^1)=1`。并且无论b的值是0还是1，`(0^b)=b`，`(1^b)=(~b)`。因此如果使用^将一个值与掩码组合，那么该值中对应的掩码位为1的位被转置，对应掩码位0的位不变。<br>
例如，要转置`flags`中位1：<br>

``` c
flags = flags ^ MASK; // MASK ＝ 0X02
```
####2.5 查看一位的值
例如：flag的位1是否为1？<br>

```
if ((flag & MASK) != 0) { // MASK = 0X02
}
或者
if ((flag & MASK) == MASK) { // MASK = 0X02
}
```
###3 一位运算符
####3.1 左移：<<
左移运算符<<将其左侧操作数的值的每位向左移动，移动的距离有右侧操作数指定。空出的位用0填充，并且丢弃移出左侧操作数末端的位。在下面的例子中，每一位向左移动两个位置：<br>

```
(1000 1010) << 2 =
(0010 1000)
```
####3.2 右移：>>
右移位运算符>>将其左侧操作数的值的每位向右移动，移动的位数有其右侧的操作数指定。丢弃移出左侧操作数右端的位。对于unsigned类型，使用0填充左端空出来的位。对于有符号类型，结果依赖于机器。空出来的位可能用0填充，或者使用符号（最左端的）位的副本填充：<br>

```
(1000 1010) >> 2  // 表达式，有符号
(0010 0010)       // 某些系统上的结果值
(1000 1010) >> 2  // 表达式，有符号
(1110 0010)       // 在另一些系统的结果值
对于无符号值，有一下结果：
(1000 1010) >> 2 // 表达式，无符号
(0010 0010)      // 所有系统的结果值
```
####3.3 用法
移位运算符能够提供快捷、高效（依赖于硬件）对2的幂的乘法和除法。<br>

| code | 功能 |
|:--:|:--:|
| number << n | number乘以2的n次幂 | 
| number >> n | 如果number非副，则用number除以2的n次幂|
###4 多选的枚举
####4.1 枚举定义

```
enum Week {
     Sunday    = 1 << 0,
     Monday    = 1 << 1,
     Tuesday   = 1 << 2,
     Wednesday = 1 << 3,
     Thursday  = 1 << 4,
     Friday    = 1 << 5,
     Saturday  = 1 << 6
}
typedef enum Week Week;
```
####4.2 操作

```
Week weekend = Sunday | Saturday;
if (weekend & Sunday) {         // 成立
} else if (weekend & Friday) {  // 不成立
}
```

